mod <- df %>%
#filter(Ethnicity == 'Black' | Ethnicity == 'White') %>%
group_by(ID) %>%
arrange(est_Grade_date) %>%
mutate(first_grade = min(est_Grade_date)) %>%
mutate(grade_measurement = seq_along(est_Grade_date)) %>%
filter(hprop > 0)
m.8 <- lmer(grade~condition*grade_measurement*liwc_hprop + (1+time|ID),
data = mod)
m.8 <- lmer(grade~condition*grade_measurement*liwc_hprop + (1+grade_measurement|ID),
data = mod)
summary(m.8)
m.8 <- lmer(grade~condition*time*liwc_hprop + (1+time|ID),
data = mod)
mod$time <- mod$est_Grade_date - mod$first_grade
m.8 <- lmer(grade~condition*time*liwc_hprop + (1+time|ID),
data = mod)
#get fixed effects
eff <- fixef(m.8)
#function for bootmer.  says 'get the fixed effects from whatever model I feed you'
FUN <- function(fit) {
return(fixef(fit))
}
library(boot)
set.seed(42)
#use.u=F, type=parametric.  see ?bootMer for details about what this does.
result.para <- bootMer(m.8, FUN, nsim=1000, use.u=F, type='parametric')
#get confidence intervals from the booted estimates
booted.lower <- rep(0, length(result.para$t0))
booted.upper <- rep(0, length(result.para$t0))
for (i in 1:length(result.para$t0)) {
a<-boot.ci(result.para, index=i, type='basic')
booted.lower[i] <- a$basic[4]
booted.upper[i] <- a$basic[5]
}
plot.dat <- data.frame(effect=names(eff), estimate=eff,
lower=booted.lower,
upper=booted.upper)
plot.dat$effect <- factor(plot.dat$effect, as.character(plot.dat$effect))
coef<-ggplot(plot.dat[plot.dat$effect!='(Intercept)',], aes(x=effect, y=estimate))
coef + geom_point(size=4, color="#144256") +
geom_errorbar(aes(ymin=lower, ymax=upper), width=.1, color="#144256") +
coord_flip() +
theme_bw() +
geom_hline(aes(yintercept=0)) +
theme(plot.title=element_text(size=10, face='bold'),
axis.title.x=element_blank(),
axis.text.x=element_text(size=10),
axis.title.y=element_text(face='bold', size=12),
axis.text.y=element_text(size=10))
plot.dat
library(pastecs)
install.packages('pastecs')
library(pastecs)
mod$time
daystoyears(mod$time)
mod$time/365.25
mod$time <- mod$time/365.25
mod$time <- mod$time/365.25
m.8 <- lmer(grade~condition*time*liwc_hprop + (1+time|ID),
data = mod)
summary(m.8)
data <- data.frame(grade=mod$grade, time=mod$time, liwc_hprop=mod$liwc_hprop,
ID=mod$ID, condition=mod$condition)
data <- data.frame(grade=mod$grade, time=mod$time, liwc_hprop=mod$liwc_hprop,
ID=mod$ID, condition=mod$condition)
mm <- model.matrix(terms(m.8), data)
#obtain predicted values for fixed and random effects
predict.data <- data.frame(data, random=predict(m.8, newdata=data, allow.new.levels = T),
fixed=predict(m.8, re.form=NA, newdata=data))
# This constructs a rough 95% confidence interval
# http://glmm.wikidot.com/faq----
pvar1 <- diag(mm %*% tcrossprod(vcov(m.8),mm))
cmult <- 2
predict.data$ci.high <- predict.data$fixed + cmult*sqrt(pvar1)
predict.data$ci.low <- predict.data$fixed - cmult*sqrt(pvar1)
#only keep one row per participant per experimental cell
#predict.data <- predict.data[,2:8]
#predict.data <- predict.data[!duplicated(predict.data),]
predict.data <- predict.data[!is.na(predict.data$condition),]
#predict.data <- predict.data[which(predict.data$grade_measurement < 9),]
ggplot(predict.data) +
geom_line(aes(grade_measurement, fixed, color=condition),  size=1) +
geom_line(aes(grade_measurement, random, color=condition, group=ID), size=1,
alpha=.05) +
facet_grid(~liwc_hprop) +
theme_bw() + scale_color_manual(values=c('#144256', '#88301B'))
ggplot(predict.data) +
geom_line(aes(time, fixed, color=condition),  size=1) +
geom_line(aes(time, random, color=condition, group=ID), size=1,
alpha=.05) +
facet_grid(~liwc_hprop) +
theme_bw() + scale_color_manual(values=c('#144256', '#88301B'))
mod$liwc_hprop <- factor(mod$liwc_hprop)
ggplot(predict.data) +
geom_line(aes(time, fixed, color=condition),  size=1) +
geom_line(aes(time, random, color=condition, group=ID), size=1,
alpha=.05) +
facet_grid(~liwc_hprop) +
theme_bw() + scale_color_manual(values=c('#144256', '#88301B'))
str(predict.data$condition)
str(predict.data$time)
as.numeric(predict.data$time)
as.numeric(as.character(predict.data$time))
min(as.numeric(as.character(predict.data$time)))
max(as.numeric(as.character(predict.data$time)))
predict.data$time
mod <- df %>%
group_by(ID) %>%
arrange(est_Grade_date) %>%
mutate(first_grade = min(est_Grade_date)) %>%
mutate(grade_measurement = seq_along(est_Grade_date)) %>%
filter(hprop > 0)
mod$time <- mod$est_Grade_date - mod$first_grade
mod$time <- mod$time/365.25
mod$liwc_hprop <- factor(mod$liwc_hprop)
mod$time
m.8 <- lmer(grade~condition*time*liwc_hprop + (1+time|ID),
data = mod)
data <- data.frame(grade=mod$grade, time=mod$time, liwc_hprop=mod$liwc_hprop,
ID=mod$ID, condition=mod$condition)
#get the matrix for our model
mm <- model.matrix(terms(m.8), data)
#obtain predicted values for fixed and random effects
predict.data <- data.frame(data, random=predict(m.8, newdata=data, allow.new.levels = T),
fixed=predict(m.8, re.form=NA, newdata=data))
# This constructs a rough 95% confidence interval
# http://glmm.wikidot.com/faq----
pvar1 <- diag(mm %*% tcrossprod(vcov(m.8),mm))
cmult <- 2
predict.data$ci.high <- predict.data$fixed + cmult*sqrt(pvar1)
predict.data$ci.low <- predict.data$fixed - cmult*sqrt(pvar1)
#only keep one row per participant per experimental cell
#predict.data <- predict.data[,2:8]
#predict.data <- predict.data[!duplicated(predict.data),]
predict.data <- predict.data[!is.na(predict.data$condition),]
#predict.data <- predict.data[which(predict.data$grade_measurement < 9),]
ggplot(predict.data) +
geom_line(aes(time, fixed, color=condition),  size=1) +
geom_line(aes(time, random, color=condition, group=ID), size=1,
alpha=.05) +
facet_grid(~liwc_hprop) +
theme_bw() + scale_color_manual(values=c('#144256', '#88301B'))
mod$time
as.numeric(predict.data$time)
predict.data$time <- as.numeric(predict.data$time)
ggplot(predict.data) +
geom_line(aes(time, fixed, color=condition),  size=1) +
geom_line(aes(time, random, color=condition, group=ID), size=1,
alpha=.05) +
facet_grid(~liwc_hprop) +
theme_bw() + scale_color_manual(values=c('#144256', '#88301B'))
predict.data <- predict.data[which(predict.data$time < 2),]
ggplot(predict.data) +
geom_line(aes(time, fixed, color=condition),  size=1) +
geom_line(aes(time, random, color=condition, group=ID), size=1,
alpha=.05) +
facet_grid(~liwc_hprop) +
theme_bw() + scale_color_manual(values=c('#144256', '#88301B'))
#get fixed effects
eff <- fixef(m.8)
#function for bootmer.  says 'get the fixed effects from whatever model I feed you'
FUN <- function(fit) {
return(fixef(fit))
}
library(boot)
set.seed(42)
#use.u=F, type=parametric.  see ?bootMer for details about what this does.
result.para <- bootMer(m.8, FUN, nsim=1000, use.u=F, type='parametric')
#get confidence intervals from the booted estimates
booted.lower <- rep(0, length(result.para$t0))
booted.upper <- rep(0, length(result.para$t0))
for (i in 1:length(result.para$t0)) {
a<-boot.ci(result.para, index=i, type='basic')
booted.lower[i] <- a$basic[4]
booted.upper[i] <- a$basic[5]
}
plot.dat <- data.frame(effect=names(eff), estimate=eff,
lower=booted.lower,
upper=booted.upper)
plot.dat$effect <- factor(plot.dat$effect, as.character(plot.dat$effect))
coef<-ggplot(plot.dat[plot.dat$effect!='(Intercept)',], aes(x=effect, y=estimate))
coef + geom_point(size=4, color="#144256") +
geom_errorbar(aes(ymin=lower, ymax=upper), width=.1, color="#144256") +
coord_flip() +
theme_bw() +
geom_hline(aes(yintercept=0)) +
theme(plot.title=element_text(size=10, face='bold'),
axis.title.x=element_blank(),
axis.text.x=element_text(size=10),
axis.title.y=element_text(face='bold', size=12),
axis.text.y=element_text(size=10))
str(mod$condition)
#across time, given that they hedged
mod <- df %>%
#filter(Ethnicity == 'Black' | Ethnicity == 'White') %>%
group_by(ID) %>%
arrange(est_Grade_date) %>%
mutate(first_grade = min(est_Grade_date)) %>%
mutate(grade_measurement = seq_along(est_Grade_date)) %>%
filter(hrel > 0)
mod$time <- mod$est_Grade_date - mod$first_grade
mod$time <- mod$time/365.25
mod$liwc_hrel <- factor(mod$liwc_hrel)
m.9 <- lmer(grade~condition*time*liwc_hrel + (1+time|ID),
data = mod)
data <- data.frame(grade=mod$grade, time=mod$time, liwc_hrel=mod$liwc_hrel,
ID=mod$ID, condition=mod$condition)
mm <- model.matrix(terms(m.9), data)
predict.data <- data.frame(data, random=predict(m.9, newdata=data, allow.new.levels = T),
fixed=predict(m.9, re.form=NA, newdata=data))
mod <- df %>%
#filter(Ethnicity == 'Black' | Ethnicity == 'White') %>%
group_by(ID) %>%
arrange(est_Grade_date) %>%
mutate(first_grade = min(est_Grade_date)) %>%
mutate(grade_measurement = seq_along(est_Grade_date)) %>%
filter(hprop > 0)
mod$time <- mod$est_Grade_date - mod$first_grade
mod$time <- mod$time/365.25
mod$liwc_hprop <- factor(mod$liwc_hprop)
m.8 <- lmer(grade~condition*time*liwc_hprop + (1+time|ID),
data = mod)
data <- data.frame(grade=mod$grade, time=mod$time, liwc_hprop=mod$liwc_hprop,
ID=mod$ID, condition=mod$condition)
#get the matrix for our model
mm <- model.matrix(terms(m.8), data)
#obtain predicted values for fixed and random effects
predict.data <- data.frame(data, random=predict(m.8, newdata=data, allow.new.levels = T),
fixed=predict(m.8, re.form=NA, newdata=data))
# This constructs a rough 95% confidence interval
# http://glmm.wikidot.com/faq----
pvar1 <- diag(mm %*% tcrossprod(vcov(m.8),mm))
cmult <- 2
predict.data$ci.high <- predict.data$fixed + cmult*sqrt(pvar1)
predict.data$ci.low <- predict.data$fixed - cmult*sqrt(pvar1)
#only keep one row per participant per experimental cell
#predict.data <- predict.data[,2:8]
#predict.data <- predict.data[!duplicated(predict.data),]
predict.data <- predict.data[!is.na(predict.data$condition),]
predict.data$time <- as.numeric(predict.data$time)
predict.data <- predict.data[which(predict.data$time <= 2),]
ggplot(predict.data) +
geom_line(aes(time, fixed, color=condition),  size=1) +
geom_line(aes(time, random, color=condition, group=ID), size=1,
alpha=.05) +
facet_grid(~liwc_hprop) +
theme_bw() + scale_color_manual(values=c('#144256', '#88301B'))
predict.data <- data.frame(data, random=predict(m.8, newdata=data, allow.new.levels = T),
fixed=predict(m.8, re.form=NA, newdata=data))
# This constructs a rough 95% confidence interval
# http://glmm.wikidot.com/faq----
pvar1 <- diag(mm %*% tcrossprod(vcov(m.8),mm))
cmult <- 2
predict.data$ci.high <- predict.data$fixed + cmult*sqrt(pvar1)
predict.data$ci.low <- predict.data$fixed - cmult*sqrt(pvar1)
#only keep one row per participant per experimental cell
#predict.data <- predict.data[,2:8]
#predict.data <- predict.data[!duplicated(predict.data),]
predict.data <- predict.data[!is.na(predict.data$condition),]
predict.data$time <- as.numeric(predict.data$time)
predict.data <- predict.data[which(predict.data$time =< 2),]
ggplot(predict.data) +
geom_line(aes(time, fixed, color=condition),  size=1) +
geom_line(aes(time, random, color=condition, group=ID), size=1,
alpha=.05) +
facet_grid(~liwc_hprop) +
theme_bw() + scale_color_manual(values=c('#144256', '#88301B'))
plot.dat
ggplot(predict.data) +
geom_line(aes(time, fixed, color=condition),  size=1) +
geom_line(aes(time, random, color=condition, group=ID), size=1,
alpha=.05) +
facet_wrap(~liwc_hrel) +
theme_bw() + scale_color_manual(values=c('#144256', '#88301B'))
m.9 <- lmer(grade~condition*time*liwc_hrel + (1+time|ID),
data = mod)
data <- data.frame(grade=mod$grade, time=mod$time, liwc_hrel=mod$liwc_hrel,
ID=mod$ID, condition=mod$condition)
#get the matrix for our model
mm <- model.matrix(terms(m.9), data)
#obtain predicted values for fixed and random effects
predict.data <- data.frame(data, random=predict(m.9, newdata=data, allow.new.levels = T),
fixed=predict(m.9, re.form=NA, newdata=data))
# This constructs a rough 95% confidence interval
# http://glmm.wikidot.com/faq----
pvar1 <- diag(mm %*% tcrossprod(vcov(m.9),mm))
cmult <- 2
predict.data$ci.high <- predict.data$fixed + cmult*sqrt(pvar1)
predict.data$ci.low <- predict.data$fixed - cmult*sqrt(pvar1)
#only keep one row per participant per experimental cell
#predict.data <- predict.data[,2:8]
#predict.data <- predict.data[!duplicated(predict.data),]
predict.data <- predict.data[!is.na(predict.data$condition),]
predict.data <- predict.data[which(predict.data$time <= 2),]
ggplot(predict.data) +
geom_line(aes(time, fixed, color=condition),  size=1) +
geom_line(aes(time, random, color=condition, group=ID), size=1,
alpha=.05) +
facet_wrap(~liwc_hrel) +
theme_bw() + scale_color_manual(values=c('#144256', '#88301B'))
predict.data$time <- as.numeric(predict.data$time)
ggplot(predict.data) +
geom_line(aes(time, fixed, color=condition),  size=1) +
geom_line(aes(time, random, color=condition, group=ID), size=1,
alpha=.05) +
facet_wrap(~liwc_hrel) +
theme_bw() + scale_color_manual(values=c('#144256', '#88301B'))
summary(m.9)
#get fixed effects
eff <- fixef(m.9)
#function for bootmer.  says 'get the fixed effects from whatever model I feed you'
FUN <- function(fit) {
return(fixef(fit))
}
library(boot)
set.seed(42)
#use.u=F, type=parametric.  see ?bootMer for details about what this does.
result.para <- bootMer(m.9, FUN, nsim=1000, use.u=F, type='parametric')
#get confidence intervals from the booted estimates
booted.lower <- rep(0, length(result.para$t0))
booted.upper <- rep(0, length(result.para$t0))
for (i in 1:length(result.para$t0)) {
a<-boot.ci(result.para, index=i, type='basic')
booted.lower[i] <- a$basic[4]
booted.upper[i] <- a$basic[5]
}
plot.dat <- data.frame(effect=names(eff), estimate=eff,
lower=booted.lower,
upper=booted.upper)
plot.dat$effect <- factor(plot.dat$effect, as.character(plot.dat$effect))
coef<-ggplot(plot.dat[plot.dat$effect!='(Intercept)',], aes(x=effect, y=estimate))
coef + geom_point(size=4, color="#144256") +
geom_errorbar(aes(ymin=lower, ymax=upper), width=.1, color="#144256") +
coord_flip() +
theme_bw() +
geom_hline(aes(yintercept=0)) +
theme(plot.title=element_text(size=10, face='bold'),
axis.title.x=element_blank(),
axis.text.x=element_text(size=10),
axis.title.y=element_text(face='bold', size=12),
axis.text.y=element_text(size=10))
startYear<-1950
library(XML)
library(stringr)
getData <-function(year){
#url
url<-paste("http://www.planecrashinfo.com/", year, "/", year, ".htm", sep="")
# Read and parse HTML file
html.raw <- htmlTreeParse(url,useInternal = TRUE)
html.parse<-unlist(xpathApply(html.raw, '//td', function(x)
xpathSApply(x,".//text()", xmlValue)))
#get rid of field names
html.parse<-html.parse[5:length(html.parse)]
#Get fields into vectors to prepare for data frame
crashDates <- html.parse[seq(1, length(html.parse), 6)]
crashLocation <- html.parse[seq(2, length(html.parse), 6)]
crashOperator <- html.parse[seq(3, length(html.parse), 6)]
crashType <- html.parse[seq(4, length(html.parse), 6)]
crashOutcome <- html.parse[seq(6, length(html.parse), 6)]
#compile into data.frame
data<-data.frame(cbind(crashDates,crashLocation,crashOperator,crashType,crashOutcome))
return(data)
}
#initialize data table
compiledData <-data.frame()
#loop through years and get data
for (i in startYear:2015) {
compiledData <- rbind(compiledData, getData(i))
}
#split the crash outcome into passengers and fatalities
compiledData$crashF <- unlist(str_split(compiledData$crashOutcome, "\\/", n=2))[seq(1, length(compiledData$crashOutcome)*2, 2)]
compiledData$crashP <- unlist(str_split(compiledData$crashOutcome, "\\/", n=2))[seq(2, length(compiledData$crashOutcome)*2, 2)]
compiledData$crashP <- unlist(str_split(compiledData$crashP, "\\(", n=2))[seq(1, length(compiledData$crashP)*2, 2)]
#coerce fields to appropriate data types
compiledData$crashF <-as.numeric(compiledData$crashF)
compiledData$crashP <-as.numeric(compiledData$crashP)
compiledData$Prop<-round(compiledData$crashF/compiledData$crashP,2)
compiledData$crashDates<-as.Date(compiledData$crashDates,"%d %b %Y")
compiledData$crashYear <- format(compiledData$crashDates, format="%Y")
#Fix certain locations to allow for mapping
compiledData$crashLocation<-str_replace(compiledData$crashLoc, "Near ", "")
compiledData$crashLocation<-str_replace(compiledData$crashLoc, "Off ", "")
head(compiledData)
histogram(compiledData$crashYear)
hist(compiledData$crashYear)
hist(as.numeric(compiledData$crashYear))
df <- compiledData %>%
group_by(crashYear) %>%
summarise(crashes = length(crashYear)) %>%
ungroup()
head(df)
ggplot(compiledData, aes(x=crashYear, y=crashes)) +
geom_line()
ggplot(df, aes(x=crashYear, y=crashes)) +
geom_line()
ggplot(df) +
geom_line(, aes(x=crashYear, y=crashes))
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes))
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1))
library(ggplot2)
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1)) +
theme_bw()
str(df$crashYear)
df$crashYear <- as.numeric(df$crashYear)
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1)) +
theme_bw()
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1)) +
scale_x_continuous(breaks=seq(1950, 2015, 5))
theme_bw()
library(ggplot2)
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1)) +
scale_x_continuous(breaks=seq(1950, 2015, 5))+
theme_bw()
as.Date(01-01-2015)
as.Date(01-01-2015, format='%mm-%dd-%yyyy')
as.Date(01-01-2015, format='%m-%d-%Y')
start <- '01-01-2015'
now <- '05-15-2015'
as.Date(start, format='%m-%d-%Y')
as.Date(now, format='%m-%d-%Y') - as.Date(start, format='%m-%d-%Y')
a <- as.Date(now, format='%m-%d-%Y') - as.Date(start, format='%m-%d-%Y')
a
365-a
a/365
365-a/365
(365-a)/365
134/365
df
df[66]
df[66,]
5/.6
5/.64
5/.5
df[which(df$crashYear == 2015),]
df[which(df$crashYear == 2015),]
df$crashes[which(df$crashYear == 2015),]
df$crashes[which(df$crashYear == 2015)]
df$crashes[which(df$crashYear == 2015)]/year.remaining
year.complete <- 134/365
year.remaining <- 1-year.complete
df$crashes[which(df$crashYear == 2015)]/year.remaining
estimated.total <- df$crashes[which(df$crashYear == 2015)]/year.remaining
df$crashes[which(df$crashYear == 2015)] <- estimated.total
library(ggplot2)
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1)) +
scale_x_continuous(breaks=seq(1950, 2015, 5))+
theme_bw()
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1, color="#144256")) +
scale_x_continuous(breaks=seq(1950, 2015, 5)) +
theme_bw()
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1, color='#88301B')) +
scale_x_continuous(breaks=seq(1950, 2015, 5)) +
theme_bw()
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1)) +
scale_x_continuous(breaks=seq(1950, 2015, 5)) +
scale_color_manual(value='#88301B')
theme_bw()
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1), color='#88301B') +
scale_x_continuous(breaks=seq(1950, 2015, 5)) +
theme_bw()
library(ggplot2)
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1), color='#88301B', size=2) +
scale_x_continuous(breaks=seq(1950, 2015, 5)) +
theme_bw()
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1), color='#88301B', size=1.5) +
scale_x_continuous(breaks=seq(1950, 2015, 5)) +
theme_bw()
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1), color='#88301B', size=1) +
scale_x_continuous(breaks=seq(1950, 2015, 5)) +
theme_bw()
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1), color='#88301B') +
scale_x_continuous(breaks=seq(1950, 2015, 5)) +
theme_bw()
ggplot(df) +
geom_line(aes(x=crashYear, y=crashes, group=1), color='#88301B', size=1) +
scale_x_continuous(breaks=seq(1950, 2015, 5)) +
theme_bw()
input <- commandArgs(trailingOnly = TRUE)
KnitPost <- function(input, base.url = "/") {
require(knitr)
opts_knit$set(base.url = base.url)
fig.path <- paste0("../figs/", sub(".Rmd$", "", basename(input)), "/")
opts_chunk$set(fig.path = fig.path)
opts_chunk$set(fig.cap = "center")
render_jekyll()
print(paste0("../_posts/", sub(".Rmd$", "", basename(input)), ".md"))
knit(input, output = paste0("../_posts/", sub(".Rmd$", "", basename(input)), ".md"), envir = parent.frame())
}
KnitPost('../riddlet.github.io/_drafts/_posts/planes.Rmd')
setwd("~/Documents/Gits/riddlet.github.io/_drafts/_posts")
setwd("~/Documents/Gits/riddlet.github.io/_drafts/_posts")
write.csv(compiledData, "CompiledCrashData.csv")
a<-read.csv('../data/CompiledCrashData.csv')
head(a)
KnitPost('../riddlet.github.io/_drafts/_posts/planes.Rmd')
KnitPost('planes.Rmd')
